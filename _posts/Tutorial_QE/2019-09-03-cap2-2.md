---
title: "Tutorial Quantum ESPRESSO: Sistemas bidimensionais (2D)"
date: 2019-08-30
tags: [QE, Tutorial]
classes: wide
header:
  teaser: images/posts/tutorial_qe/logo_header.jpg
excerpt: "Obtendo a estrutura de equilíbrio, energia coesiva e modos vibracionais para sistemas bidimensionais (2D)"
mathjax: "true"
---


Dentre os mais diversos sistemas 2D que podemos explorar, de longe o mais famoso e estudado na literatura é o grafeno. Ele apresenta dois átomos em uma célula unitária hexagonal, como representado na figura abaixo.

<img src="{{ site.url }}{{ site.baseurl }}/images/posts/tutorial_qe/grafeno.png" alt="Representação da célula unitária do grafeno e dos átomos não equivalentes">

**Figura 1:** (a) Representação da célula unitária do grafeno e dos átomos não equivalentes. (b) Representação da primeira zona de Brillouin e os pontos de alta simetria.

> Uma rede do tipo *"honeycomb"* não é uma rede de Bravais. A rede de Bravais do grafeno é uma rede *hexagonal*. Uma rede Bravais hexagonal é aquela cuja célula unitária é um prisma com bases hexagonais e cujos pontos de rede estão localizados nos vértices da célula unitária e nos centro da base.

Podemos representar a célula unitária do grafeno de duas formas: **(1)** Um átomo posicionado no centro (0, 0, 0) e outro na posição (1/3, 2/3, 0); **(2)** Um átomo em (2/3, 1/3, 0) e outro em (1/3, 2/3, 0). Ambas são absolutamente equivalentes, entretanto a primeira representação apresenta simetria $$P\\Bar{6}m2$$ #187 e a segunda $$P6/mmm$$ #191 apresenando 24 elementos de simetria.

## Estrutura em equilíbrio

Assim como fizemos para moléculas, precisamos primeiramente obter a estrutura de equilíbrio para o sistema. Nesse caso, entretanto, não iremos variar a posição dos átomos, mas manter suas posições na célula unitária fixas e variar o parâmetro $a$. Além disso, de maneira análoga como fizemos anteriormente utilizaremos um \textit{slab} entre as folhas para que tenhamos um sistema 2D.

```bash
#!/bin/bash

CMD_PW="mpirun -np 4 /home/interlab/qe-6.3/bin/pw.x"
PREFIX="grafeno"
PSEUDO_DIR="/home/interlab/pseudo/"
CALC='scf'

for celldm in 4.181673 4.23058145 4.27948991 4.32839837 4.37730682
4.42621528 4.47512373 4.52403219 4.57294065 4.6218491 4.67075756
4.71966601 4.76857447 4.81748293 4.86639138 4.91529984 4.96420829
5.01311675 5.06202521 5.11093366

do
#Make SCF calculation
cat>$PREFIX.$celldm.$CALC.in<<EOF
grafeno1x1 - PW SCF calculation
 &control
    calculation = '$CALC' , restart_mode = 'from_scratch' ,
    wf_collect = .false. , outdir = '.' ,
    pseudo_dir = '$PSEUDO_DIR' , prefix = '$PREFIX' ,
 /
 &system
    ibrav = 4 , celldm(1) = $celldm, celldm(3) = 10,
    nat =  2 , ntyp = 1 ,
    ecutwfc = 80.0 , ecutrho = 600.0 ,
 /
 &electrons
    conv_thr =  1.0D-10 , electron_maxstep = 5000 ,
 /
ATOMIC_SPECIES
    C   12.0107  C.pbe-van_ak.UPF
ATOMIC_POSITIONS (crystal)
C        0.000000000   0.000000000   0.000000000
C        0.333333333   0.666666667   0.000000000

K_POINTS automatic
   12 12 1   0 0 0
EOF
$CMD_PW < $PREFIX.$celldm.$CALC.in > $PREFIX.$celldm.$CALC.out
done
```

Vamos fazer um processo análogo ao feito para moléculas, entretanto dessa vez vamos automatizar um pouco o processo. No *script* grafeno.sh utilizamos um **for** para executar os cálculos sequencias para os diversos parâmetros $$a$$. No código **run.py** escrevemos um programa para abrir todos os arquivos **\*.out**, pegar as energias, fazer o ajuste do potencial de Morse e gerar o gráfico. Facilita um pouco a vida, não é mesmo?

```python
import os
import matplotlib.pyplot as plt
import numpy as np
import scipy.optimize as sci

def anarmonic_p(x, De, re, a, D0):
    return De*(1 - np.exp(-a*(x - re)))**2 + D0

def r_square_g(xs, ys, yteo):

        ymed = sum(ys)/len(ys)
        SQtot = sum([(i-ymed)**2 for i in ys])
        SQres = sum([(i-ymed)**2 for i in yteo])
        return SQres/SQtot

def ajust(xdata, ydata, p0 = [0.8,4.6,2.57,-20]):

     popt, pcov = sci.curve_fit(anarmonic_p,
                                xdata, ydata, p0, method='dogbox')

     r2 = r_square_g(xdata, ydata, anarmonic_p(xdata, *popt))

     return anarmonic_p(xdata, *popt), r2, popt

list_output = [name_file for name_file in
               os.listdir(os.getcwd()) if '.out' in name_file]
d_NN = []
energias = []
for name in list_output:
    d_NN += [float(name[8:-8])]
    arquivo = open(os.path.join(os.getcwd(), name)).readlines()
    e = [i for i in arquivo if '!' in i]
    energias += [float(e[0][36:-5])]

aj = ajust(d_NN, energias)
print('De = %f, re = %f, a = %f, D0 = %f, R2= %f'
        %(aj[-1][0], aj[-1][1], aj[-1][2], aj[-1][3], aj[-2]))

plt.plot(np.linspace(d_NN[0], d_NN[-1], 200),
         anarmonic_p(np.linspace(d_NN[0], d_NN[-1], 200),
                     *aj[-1]),  color='black')
plt.plot(d_NN, energias, 'o', ms=8, lw=2, alpha=1,
         mfc='red', color='black')
plt.xlabel(r'$a$ ($\AA{}$)', fontsize=14)
plt.ylabel('Energia Total (Ry)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()
```


Como resultado do ajuste do potencial de Morse obtemos os parâmetros: $$D_e = 1.504019, r_e = 4.659226, a = 0.554086, D_0 = -24.857592, R^2= 1.000000$$.
Como resultado do ajuste do potencial harmônico obtemos os parâmetros: $$k = 0.887535, x_{0} = 4.663421, V_0 = -24.858048, R^2= 0.998246$$.

<img src="{{ site.url }}{{ site.baseurl }}/images/posts/tutorial_qe/grafeno_curve.png" alt="E(a) para o grafeno">
**Figura 2:** Energia em função do parâmetro $$a$$ da célula unitária, $$E(a)$$ para o grafeno. Os pontos vermelhos são os valores calculados e a linha preta um ajuste de um potencial de Morse e a linha azul o ajuste de um potencial harmônico.
